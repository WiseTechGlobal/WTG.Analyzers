<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ output extension=".g.cs" #>
// <auto-generated />
using Microsoft.CodeAnalysis;

<#
var root = XElement.Load(Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), "Rules.xml"));
var prefix = root.Attribute("prefix").Value;

var rules = Enumerable.ToArray(
	from categoryNode in root.Elements(ns + "category")
	let category = categoryNode.Attribute("name").Value
	let categoryID = int.Parse(categoryNode.Attribute("id").Value)
	from ruleNode in categoryNode.Elements(ns + "rule")
	let ruleID = ruleNode.Attribute("id").Value
	select new
	{
		ID = prefix + (categoryID + int.Parse(ruleID.PadLeft(2, '0'))).ToString("0000"),
		Name = ruleNode.Attribute("name").Value,
		Severity = ruleNode.Attribute("severity")?.Value ?? "Warning",
		Category = category,
		Title = ruleNode.Element(ns + "title").Value,
		Messages = Enumerable.ToArray(
			from messageElement in ruleNode.Elements(ns + "message")
			select new FormatMessage(
				messageElement.Attribute("name")?.Value,
				messageElement.Value)),
		Description = ruleNode.Element(ns + "description").Value,
		Tags = ruleNode.Elements(ns + "tag").Select(x => x.Value).ToArray(),
	});

var categories = rules.Select(x => x.Category).Distinct().ToArray();

#>
namespace WTG.Analyzers
{
	static class Rules
	{
<#
foreach (var category in categories)
{
#>
		public const string <#=category#>Category = <#=Escape(category)#>;
<#
}

foreach (var rule in rules)
{
#>
		public const string <#=rule.Name#>DiagnosticID = <#=Escape(rule.ID)#>;
<#
}

foreach (var rule in rules)
{
	foreach (var message in rule.Messages)
	{
#>

		public static readonly DiagnosticDescriptor <#=rule.Name#><#=message.NameSuffix#>Rule = new DiagnosticDescriptor(
			<#=rule.Name#>DiagnosticID,
			<#=Escape(rule.Title)#>,
			<#=Escape(message.MessageFormat)#>,
			<#=rule.Category#>Category,
			DiagnosticSeverity.<#=rule.Severity#>,
			isEnabledByDefault: true,
			description: <#=Escape(rule.Description)#><#

		if (rule.Tags.Length > 0)
		{
		#>,
			customTags: new[]
			{
<#
			foreach (var tag in rule.Tags)
			{
#>
				WellKnownDiagnosticTags.<#=tag#>,
<#
			}
#>
			}<#
		}

			#>);
<#
	}
}

foreach (var rule in rules)
{
	foreach (var message in rule.Messages)
	{
#>

		/// <summary>
		/// <#=message.RawMessage#>
		/// </summary>
		public static Diagnostic Create<#=rule.Name#><#=message.NameSuffix#>Diagnostic(Location location<#

		foreach (var arg in message.Arguments)
		{
			#>, object <#=arg#><#
		}
		#>)
		{
			return Diagnostic.Create(<#=rule.Name#><#=message.NameSuffix#>Rule, location<#

		foreach (var arg in message.Arguments)
		{
			#>, <#=arg#><#
		}
			#>);
		}
<#
	}
}

#>
	}
}
<#+
class FormatMessage
{
	public FormatMessage(string name, string rawMessage)
	{
		var arguments = new List<string>();
		var builder = new StringBuilder();
		var start = 0;

		for (int i = 0; i < rawMessage.Length; i++)
		{
			var c = rawMessage[i];

			if (c == '{')
			{
				builder.Append(rawMessage, start, i - start + 1);

				if (i + 1 < rawMessage.Length && rawMessage[i + 1] == '{')
				{
					i++;
				}
				else
				{
					start = i + 1;
				}
			}
			else if (c == '}')
			{
				var indexText = rawMessage.Substring(start, i - start);
				var index = arguments.IndexOf(indexText);

				if (index < 0)
				{
					index = arguments.Count;
					arguments.Add(indexText);
				}

				builder.Append(index);
				start = i;
			}
		}

		builder.Append(rawMessage, start, rawMessage.Length - start);

		Name = name;
		NameSuffix = name == null ? string.Empty : "_" + name;
		RawMessage = rawMessage;
		MessageFormat = builder.ToString();
		Arguments = arguments;
	}

	public string Name { get; }
	public string NameSuffix { get; }
	public string RawMessage { get; }
	public string MessageFormat { get; }
	public IEnumerable<string> Arguments { get; }
}

static string Escape(string text)
{
	// should really be doing proper escaping, but don't really need it just yet.
	return "\"" + text + "\"";
}

XNamespace ns = "http://cargowise.com/glow/2016/09/10/Rules.xsd";
#>