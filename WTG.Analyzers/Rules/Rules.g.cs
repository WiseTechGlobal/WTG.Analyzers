// <auto-generated />
using Microsoft.CodeAnalysis;

namespace WTG.Analyzers
{
	static class Rules
	{
		public const string CodingConventionCategory = "CodingConvention";
		public const string CorrectnessCategory = "Correctness";
		public const string DecruftificationCategory = "Decruftification";
		public const string MaintainabilityCategory = "Maintainability";
		public const string DoNotUseThePrivateKeywordDiagnosticID = "WTG1001";
		public const string UseVarWherePossibleDiagnosticID = "WTG1002";
		public const string DoNotLeaveWhitespaceOnTheEndOfTheLineDiagnosticID = "WTG1003";
		public const string IndentWithTabsRatherThanSpacesDiagnosticID = "WTG1004";
		public const string UseConsistentLineEndingsDiagnosticID = "WTG1005";
		public const string DoNotUseTheInternalKeywordForTopLevelTypesDiagnosticID = "WTG1006";
		public const string DoNotCompareBoolToAConstantValueDiagnosticID = "WTG1007";
		public const string DoNotCompareBoolToAConstantValueInAnExpressionDiagnosticID = "WTG1008";
		public const string DoNotConfigureAwaitFromAsyncVoidDiagnosticID = "WTG2001";
		public const string RemovedOrphanedSuppressionsDiagnosticID = "WTG3001";
		public const string DoNotNestRegionsDiagnosticID = "WTG3101";
		public const string RegionsShouldNotSplitStructuresDiagnosticID = "WTG3102";

		public static readonly DiagnosticDescriptor DoNotUseThePrivateKeywordRule = new DiagnosticDescriptor(
			DoNotUseThePrivateKeywordDiagnosticID,
			"Do not use the 'private' keyword.",
			"Our convention is to omit the 'private' modifier where it is already the default.",
			CodingConventionCategory,
			DiagnosticSeverity.Hidden,
			isEnabledByDefault: true,
			description: "Remove the 'private' keyword.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor UseVarWherePossibleRule = new DiagnosticDescriptor(
			UseVarWherePossibleDiagnosticID,
			"Use the 'var' keyword instead of an explicit type where possible.",
			"The compiler is able to correctly identify which type to use here, so replace the explicit type with var.",
			CodingConventionCategory,
			DiagnosticSeverity.Hidden,
			isEnabledByDefault: true,
			description: "Replace with the 'var' keyword.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor DoNotLeaveWhitespaceOnTheEndOfTheLineRule = new DiagnosticDescriptor(
			DoNotLeaveWhitespaceOnTheEndOfTheLineDiagnosticID,
			"Do not leave whitespace on the end of the line.",
			"You have meaningless whitespace on the end of the line, remove it.",
			CodingConventionCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Remove whitespace from the end of the line.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor IndentWithTabsRatherThanSpacesRule = new DiagnosticDescriptor(
			IndentWithTabsRatherThanSpacesDiagnosticID,
			"Indent with tabs rather than spaces.",
			"Our coding convention is to use tabs, not spaces, you may need to fix your settings.",
			CodingConventionCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Replace the leading spaces with tabs.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor UseConsistentLineEndingsRule = new DiagnosticDescriptor(
			UseConsistentLineEndingsDiagnosticID,
			"Use consistent line endings.",
			"All line endings should be using CRLF, this issue usually occures when copying code from another source.",
			CodingConventionCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Replace the line ending character sequence with CRLF.");

		public static readonly DiagnosticDescriptor DoNotUseTheInternalKeywordForTopLevelTypesRule = new DiagnosticDescriptor(
			DoNotUseTheInternalKeywordForTopLevelTypesDiagnosticID,
			"Do not use the 'internal' keyword for non-nested type definitions.",
			"Our convention is to omit the 'internal' modifier on types where it is already the default.",
			CodingConventionCategory,
			DiagnosticSeverity.Hidden,
			isEnabledByDefault: true,
			description: "Remove the 'internal' keyword.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor DoNotCompareBoolToAConstantValueRule = new DiagnosticDescriptor(
			DoNotCompareBoolToAConstantValueDiagnosticID,
			"Do not compare bool to a constant value.",
			"Do not compare bool to a constant value.",
			CodingConventionCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Either use the original value as-is, or use a logical-not operator ('!')",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor DoNotCompareBoolToAConstantValueInAnExpressionRule = new DiagnosticDescriptor(
			DoNotCompareBoolToAConstantValueInAnExpressionDiagnosticID,
			"Do not compare bool to a constant value in an expression.",
			"Do not compare bool to a constant value in an expression.",
			CodingConventionCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Either use the original value as-is, or use a logical-not operator ('!')",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor DoNotConfigureAwaitFromAsyncVoidRule = new DiagnosticDescriptor(
			DoNotConfigureAwaitFromAsyncVoidDiagnosticID,
			"Do not use ConfigureAwait from an async void method.",
			"ConfigureAwait(false) may result in the async method resuming on a non-deterministic thread, and if an exception is then thrown, it will likely be unhandled and result in process termination.",
			CorrectnessCategory,
			DiagnosticSeverity.Error,
			isEnabledByDefault: true,
			description: "Remove the ConfigureAwait call, or return Task.");

		public static readonly DiagnosticDescriptor RemovedOrphanedSuppressionsRule = new DiagnosticDescriptor(
			RemovedOrphanedSuppressionsDiagnosticID,
			"Remove orphaned suppressions.",
			"Encountered a code analysis suppression for the non-existent {0} '{1}'. Remove or update it.",
			DecruftificationCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "If you change or remove a type or member that had a code analysis suppression against it, be sure to remove any orphaned suppression attributes. This is usually easier to maintain if the suppression attributes are applied directly to the type/member rather than applied to the assembly in a GlobalSuppressions.cs file.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor DoNotNestRegionsRule = new DiagnosticDescriptor(
			DoNotNestRegionsDiagnosticID,
			"Do not nest regions.",
			"Do not nest regions.",
			MaintainabilityCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "Regions tend to obscure the code and nesting them generally indicates that either the code is poorly structured or trying to do too much.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		public static readonly DiagnosticDescriptor RegionsShouldNotSplitStructuresRule = new DiagnosticDescriptor(
			RegionsShouldNotSplitStructuresDiagnosticID,
			"Regions should not split structures.",
			"If either the start or end of a declaration/statement/expression is within a region, then both ends should be within the same region.",
			MaintainabilityCategory,
			DiagnosticSeverity.Info,
			isEnabledByDefault: true,
			description: "This region is clearly confused about what it's for, remove it.",
			customTags: new[]
			{
				WellKnownDiagnosticTags.Unnecessary,
			});

		/// <summary>
		/// Our convention is to omit the 'private' modifier where it is already the default.
		/// </summary>
		public static Diagnostic CreateDoNotUseThePrivateKeywordDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotUseThePrivateKeywordRule, location);
		}

		/// <summary>
		/// The compiler is able to correctly identify which type to use here, so replace the explicit type with var.
		/// </summary>
		public static Diagnostic CreateUseVarWherePossibleDiagnostic(Location location)
		{
			return Diagnostic.Create(UseVarWherePossibleRule, location);
		}

		/// <summary>
		/// You have meaningless whitespace on the end of the line, remove it.
		/// </summary>
		public static Diagnostic CreateDoNotLeaveWhitespaceOnTheEndOfTheLineDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotLeaveWhitespaceOnTheEndOfTheLineRule, location);
		}

		/// <summary>
		/// Our coding convention is to use tabs, not spaces, you may need to fix your settings.
		/// </summary>
		public static Diagnostic CreateIndentWithTabsRatherThanSpacesDiagnostic(Location location)
		{
			return Diagnostic.Create(IndentWithTabsRatherThanSpacesRule, location);
		}

		/// <summary>
		/// All line endings should be using CRLF, this issue usually occures when copying code from another source.
		/// </summary>
		public static Diagnostic CreateUseConsistentLineEndingsDiagnostic(Location location)
		{
			return Diagnostic.Create(UseConsistentLineEndingsRule, location);
		}

		/// <summary>
		/// Our convention is to omit the 'internal' modifier on types where it is already the default.
		/// </summary>
		public static Diagnostic CreateDoNotUseTheInternalKeywordForTopLevelTypesDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotUseTheInternalKeywordForTopLevelTypesRule, location);
		}

		/// <summary>
		/// Do not compare bool to a constant value.
		/// </summary>
		public static Diagnostic CreateDoNotCompareBoolToAConstantValueDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotCompareBoolToAConstantValueRule, location);
		}

		/// <summary>
		/// Do not compare bool to a constant value in an expression.
		/// </summary>
		public static Diagnostic CreateDoNotCompareBoolToAConstantValueInAnExpressionDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotCompareBoolToAConstantValueInAnExpressionRule, location);
		}

		/// <summary>
		/// ConfigureAwait(false) may result in the async method resuming on a non-deterministic thread, and if an exception is then thrown, it will likely be unhandled and result in process termination.
		/// </summary>
		public static Diagnostic CreateDoNotConfigureAwaitFromAsyncVoidDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotConfigureAwaitFromAsyncVoidRule, location);
		}

		/// <summary>
		/// Encountered a code analysis suppression for the non-existent {targetKind} '{targetName}'. Remove or update it.
		/// </summary>
		public static Diagnostic CreateRemovedOrphanedSuppressionsDiagnostic(Location location, object targetKind, object targetName)
		{
			return Diagnostic.Create(RemovedOrphanedSuppressionsRule, location, targetKind, targetName);
		}

		/// <summary>
		/// Do not nest regions.
		/// </summary>
		public static Diagnostic CreateDoNotNestRegionsDiagnostic(Location location)
		{
			return Diagnostic.Create(DoNotNestRegionsRule, location);
		}

		/// <summary>
		/// If either the start or end of a declaration/statement/expression is within a region, then both ends should be within the same region.
		/// </summary>
		public static Diagnostic CreateRegionsShouldNotSplitStructuresDiagnostic(Location location)
		{
			return Diagnostic.Create(RegionsShouldNotSplitStructuresRule, location);
		}
	}
}
